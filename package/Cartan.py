# -*- coding: utf-8 -*-
__docformat__ = 'google'
"""
# Object containing the functions and data required to generate a Cartan Decomposition from a given Hamiltonian. 
from object_based.PauliOps import commutatePauliString

Authors:
* Thomas Steckmann
* Efekan Kokcu
"""

from PauliOps import commutatePauliString

class Cartan:
    """
    Class to contain the options for performing Cartan Decomposition on a Hamiltonian

    Functionality:
    * Generate Hamiltonian Algebra
    * Generate k, m, h partition
    * Choose involution (Default - Even/Odd)
    * Seed choice of h
    * Modify k (Additional Decomposition, Abelian Decomposition, Piling)
    """
    def __init__(self, hamObj, involution='evenOdd'):
        """ Generates the Cartan Object
        
        Args:
            hamObj (Hamiltonian): Passes a Hamiltonian Object containing the full information about the system
            involution (String, default='evenOdd'):
                Allows a choice of the k,m involuiton

                ### Options:
                * `'evenOdd'`: m contains an even number of non-identity pauli terms in each string, k contains an odd nunber of non-idenity elements
                * `'knejaGlaser'`: m contains elements ending in Y or X, k contains elements ending in I or Z
                * `'count' + 'X', 'Y', or 'Z'`: Counts of the number of the specified Pauli Tuple. Even count in m, odd in k
        """
        self.hamiltonian = hamObj
        self.hamTuples = self.hamiltonian.getHamTuples()
        self.g = self.makeGroup()
        self.setInvoluiton(involution)
        self.getsubalgebra()

    def setInvoluiton(self, involutionName):
        """
        Sets a new Involution using a switch
        """
        self.involution = involutionName #Store involution name

        if involutionName == 'evenOdd': 
            (self.m, self.k) = self.evenOdd(self.hamAlg)
        elif involutionName == 'knejaGlaser':
                 (self.m, self.k) = self.knejaGlaserDecomp(self.hamAlg)
        elif involutionName == 'countX':
                 (self.m, self.k) = self.elemcount(self.hamAlg, 1)
        elif involutionName == 'countY':
                 (self.m, self.k) = self.elemcount(self.hamAlg, 2)
        elif involutionName == 'countZ': (self.m, self.k) = self.elemcount(self.hamAlg)


    def makeGroup(self):
        '''
        Returns a closure of a given list of pauli strings (g). The list doesn't include any coefficients, it is just
        a tuple like (0,2,3) representing IYZ.

        Args:
            g (List of Tuples):
                A set of Pauli Strings

        Returns:
            List of Tuples: g(H), the Hamiltonian Algebra generated by the input g
        '''
        flag = 0
        while (flag == 0):
            flag = 1
            L = len(g)
            #initialize commutations
            coms = []

            #calculate all possible commutations 
            for i in range(L):
                for j in range(i,L):
                    m = commutatePauliString(1,g[i],1,g[j])
                    
                    
                    #add all new ones to the list
                    if (abs(m[0])>0) & (self.included(coms,m[1])==0) & (self.included(g,m[1])==0):
                        #set flag to 0 whenever there is a new term to be added
                        flag = 0
                        coms.append(m[1])

            #then merge initial list with these new commutations
            g = g + coms
            #print(g)
        return g
    
    def elemcount(g,element):
        '''
        Counts the number of given elements (X,Y or Z in number), and puts even numbers in m, odd numbers in k. 
        For element=2, it corresponds to \theta(g) = -g^T
        '''    
        k = []
        m = []
        
        for i in range(len(g)):
            elem = g[i]
            count = 0
            for j in range(len(elem)):
                if elem[j] == element:
                    count=count+1
            if count%2 == 0:
                m.append(elem)
            else:
                k.append(elem)
            
        return m,k
    
    def included(g,m):
        '''Following function returns 0 if tuple m is not incu=luded in tuple list g, returns 1 if it is included.
            
            Args:
                g (List of Tuples): 
                    The List of Pauli string elements in the Hamiltonian Algebra ð–Œ(H)
                m (Tuple of 0,1,2,3):
                    Pauli string in the set ð–’

            Returns: 
                1 if m is in g
                0 if not
        '''
        L = len(g)
        res = 0    
        for i in range(L):
            if g[i]==m:
                res = 1
                break
        
        return res


    def evenOdd(g):
        """ Partitions the Algebra by counting the number of non-idenity Pauli elements

        Args:
            g (List of Tuples):
                The Algebra to partition
        
        Returns:
            k (List of Tuples):
                The List of Pauli Strings with Odd non-identity terms
            m (List of Tuples):
                The List of Pauli Strings with Even non-idenity terms
        """
        k = []
        m = []
        
        for i in range(len(g)):
            elem = g[i]
            count = 0
            for j in range(len(elem)):
                if elem[j] > 0:
                    count=count+1
            if count%2 == 0:
                m.append(elem)
            else:
                k.append(elem)
                
        return m,k

    def knejaGlaser(g):
        '''
        Following one is the Kneja Glaser decomposition. 
        It corresponds to \theta(g) = III...IZ g III..IZ
        ''' 
        k = []
        m = []
        
        for i in range(len(g)):
            elem = g[i]
            last = elem[len(elem)-1]
            if  (last == 3) | (last == 0):
                m.append(elem)
            else:
                k.append(elem)
            
        return m,k

    
    def getsubalgebra(self):
        '''
        Generates h with the order of the elements in m. Seeds from the first elements in m
        '''
        h = []
        for i in range(len(self.m)):
            flag = 0
            for j in range(len(h)):
                comm = commutatePauliString(1, h[j], 1, self.m[i])
                if comm[0] != 0:
                    flag = 1
                    break
            if flag == 0:
                h.append(self.m[i]) 
                
        self.h = h
    
    def getSeededSubAlgebra(self,seedList):
        """ Generates h from a list of Commuting elements in the seedList 
        
        Args:
            seedList (List of Tuples): List of (PauliStrings). Must be commuting
        
        TODO:
            Verify that seedList is commuting
        """
        h = seedList.copy()
        for i in range(len(self.m)):
            flag = 0
            for j in range(len(h)):
                if self.m[i] == h[j]:
                    flag = 1
                    break
                    
                comm = commutatePauliString(1, h[j], 1, self.m[i])
                if comm[0] != 0:
                    flag = 1
                    break
            if flag == 0:
                h.append(self.m[i]) 
                
        self.h = h